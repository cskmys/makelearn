= Notes
:toc: left
:toclevels: 5

Make is a build system that is used to compile C/C++ programs.
It allows us to have various useful features such as recompiling only what is changed, executing instructions, conditionally compiling something etc.

This tutorial compatible version 3 and 4 of `Make`.

You can get `make` from `apt`.

== Makefile syntax
A `Makefile` has a set of rules which look like:

[source,make]
----
targets: prerequisites
    command
    ...
    command
----

[IMPORTANT]
====
`Makefile` must be tab-indented and not spaces
====

* `targets` are filenames, seperated by spaces.
Normally, there's one per rule.
* `command`(s) are series of steps used to make the targets from the pre-requisites.
They need to be tab-indented(not space).
* `prerequisites` are filenames, seperated by spaces, which need to exist in order for the commands to be run.
They are also called `dependencies`.

== Running make file

The first target is the default target, hence if you do:
----
make
----
only that will be executed.

To run a specific target:
----
make <target>
----

== Targets

A target is run when:

* it has no dependency, and the target file doesn't exist
* it has a dependency, and the dependency file:
** exists
*** but the target file doesn't exist
*** and the dependency file is newer than the target file
** doesn't exist but there is a dependency target in the makefile which doesn't run any commands which fails.
+
[NOTE]
====
Here, the dependency target is run first, and then the actual target is run as long as none of the commands inside the dependency target fail.
====
+
[CAUTION]
====
The only thing that matters here is if the commands under the dependecy's target execute succesfully or not.
It doesn't matter *if they don't create the dependency file*.
Hence, even if the dependency file is not created, as long as there's a dependency target that doesn't run any command that fails, the target will run.
====

A target is not executed when:

* it has no dependency, and the target file exists
* it has a dependency and the dependency file
** exists but is older than the target file
** doesn't exists and
*** there is no target to build it
*** the dependency's target executes a command that fails.

[NOTE]
====
The above rules gives rise to any interesting scenario.
For example, you have compiled you binary, and then you edit the binary.
Still if you run `make` whether the target of the binary will be re-run or not depends on the above rules.
Make doesn't care if you manually edited the binary.
====

[IMPORTANT]
====
Here when we say older/newer we are referring to the last file modfication time which could be the time of file creation or edit whichever happened latest.
====

=== Multiple targets

You can have multiple targets execute the same set of commands.
For example:
----
f1 f2:
    touch $@
----
`$@` is an automatic variable which will give you the current target's name.

=== Conventions

These are not keywords but just few conventions.

==== `all`
`all` as a target, is written at the top of the file with multiple targets as dependencies, to run multiple targets. 
Since it is at the top, running just `make` will build everything.

==== `clean`
`clean` as a target, is written at the end of the file with no dependencies, to remove the output of all the other targets.

== Variables

variables can be created by:
----
<var_name> = <var_value>
----
or
----
<var_name> := <var_value>
----
[NOTE]
====
There should be one space before and after `=` or `:=`
====

[IMPORTANT]
====
While assigning variables, unlike shell scripts, `"` or `'` have no meaning for `make`.

[source, make]
----
a = one two <1>
b = 'one two' <2>
c = "one two" <3>
----
<1> `a` is `one` and `two`
<2> `b` is `one two`
<3> `c` is `one two`

====

variables can be referenced by:
----
${<var_name>}
----
or
----
$(<var_name>)
----

[CAUTION]
====
Doing just:
----
$<var_name>
----
works as well.
But, it is a very bad practice.
====

=== Automatic variables
There are several https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html[automatic variables], but the most commonly used ones are:

* `@`: contains the current target
* `?`: contains all pre-requisites newer than the target
* `^`: contains all pre-requisites

=== Wildcard

Make has two wildcards.

==== `*`
This searches for matching filenames in your filesystem.
It can be used with variables, target, dependencies or in the `wildcard` function.

[WARNING]
====
Always wrap this in `wildcard` function.
If you don't then if there's no filename match, it could be taken literally. 
====

==== `%`
It is versatile and its meaning depends on where it is used:

* In matching mode, it can match one or more characters in a string.
This match is called a stem.
* In replacing mode, it replaces the matched stem.
* Also used in rule definitions and some specific functions

== Rules

=== Implicit rules

[WARNING]
====
For the purpose of readability and maintainability, it is highly recommended to not use or rely on these rules.
====

Make was built for C/C++ compilation.
It has few implicit rules and variables to ease C/C++ compilation.

* Variables
** `CC`: program for compiling `C`, default: `cc`
** `CXX`: program for compiling `C++`, default: `g++`
** `CFLAGS`: flags for `CC`
** `CXXFLAGS`: flags for `CXX`
** `CPPFLAGS`: flags for pre-processor
** `LDFLAGS`: flags for linker

* Rules
** `<file>.o` is automatically compiled from:
*** `<file>.c` by implictly executing the command:
+
----
${CC} -c ${CPPFLAGS} ${CFLAGS} $^ -o $@
----

*** `<file>.cpp` by implicitly executing the command:
+
----
${CXX} -c ${CPPFLAGS} ${CXXFLAGS} $^ -o $@
----

** `<file>` is automatically linked from `<file>.o` by implictly executing the command:
+
----
${CC} ${LDFLAGS} $^ ${LOADLIBS} ${LDLIBS} -o $@
----
